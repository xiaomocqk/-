<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <script src="../vue-2.1.3.js"></script>
</head>

<body>
    <div id="box">
        <p>Original message: {{ message }}</p>
        <p>Computed reversed message: {{ reversedMessage1 }}</p>
        <p>Methods reversed message: {{ reversedMessage2() }}</p>
    </div>
    <script>
    new Vue({
        el: "#box",
        data:{
            message: "hello,Vue.js!"
        },
        computed: {
            reversedMessage1: function(){
                return this.message.split('').reverse().join('')
            }
        },
        methods:{
            reversedMessage2: function(){
                return this.message.split('').reverse().join('')
            }
        }
    });
    // 不经过计算属性，我们可以在 method 中定义一个相同的函数来替代它。
    // 对于最终的结果，两种方式确实是相同的。
    // 然而，不同的是计算属性是基于它的依赖缓存。
    // 计算属性只有在它的相关依赖发生改变时才会重新取值。这就意味着
    // 只要 message 没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。
    </script>
</body>

</html>
